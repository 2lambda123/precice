#include "MappingConservativeNearestProjection.hpp"
#include "query/FindClosest.hpp"

namespace precice {
namespace mapping {

tarch::logging::Log MappingConservativeNearestProjection::
  _log ( "precice::mapping::MappingConservativeNearestProjection" );

MappingConservativeNearestProjection:: MappingConservativeNearestProjection ()
:
  Mapping ( TEMPORARY, FULL ),
  _weights (),
  _hasComputedMapping ( false )
{}

void MappingConservativeNearestProjection:: computeMapping()
{
  preciceTrace ( "computeMapping()" );
  _weights.resize ( input()->vertices().size() );
  for ( size_t i=0; i < input()->vertices().size(); i++ ) {
    query::FindClosest findClosest ( input()->vertices()[i].getCoords() );
    findClosest ( *output() );
    assertion ( findClosest.hasFound() );
    const query::ClosestElement& closest = findClosest.getClosest ();
    _weights[i].clear ();
    foreach ( const query::InterpolationElement& elem, closest.interpolationElements ) {
      _weights[i].push_back ( elem );
    }
  }
  _hasComputedMapping = true;
}

bool MappingConservativeNearestProjection:: hasComputedMapping ()
{
  return _hasComputedMapping;
}

void MappingConservativeNearestProjection:: map
(
  int inputDataID,
  int outputDataID )
{
  preciceTrace2 ( "map()", inputDataID, outputDataID );
  assertion ( _weights.size() == input()->vertices().size() );
  mesh::PtrData inData = input()->data ( inputDataID );
  mesh::PtrData outData = output()->data ( outputDataID );
  const utils::DynVector& inValues = inData->values();
  utils::DynVector& outValues = outData->values ();
  int dimensions = inData->getDimensions();
  assertion ( dimensions == outData->getDimensions() );
  for ( size_t i=0; i < input()->vertices().size(); i++ ) {
    size_t inOffset = i * dimensions;
    InterpolationElements& elems = _weights[i];
    foreach ( query::InterpolationElement& elem, elems ) {
      size_t outOffset = (size_t)elem.element->getID() * dimensions;
      for ( int dim=0; dim < dimensions; dim++ ) {
        assertion ( outOffset + dim < (size_t)outValues.size() );
        assertion ( inOffset + dim < (size_t)inValues.size() );
        outValues[outOffset + dim] += elem.weight * inValues[inOffset + dim];
      }
    }
  }
}

}} // namespace precice, mapping
