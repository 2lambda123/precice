#include "GeometryQueriesTest.hpp"
#include "geometry/Sphere.hpp"
#include "geometry/DriftRatchet.hpp"
#include "geometry/Cuboid.hpp"
#include "geometry/ImportGeometry.hpp"
#include "mesh/SharedPointer.hpp"
#include "query/FindClosest.hpp"
#include "query/FindVoxelContent.hpp"
#include "query/ExportVTKVoxelQueries.hpp"
#include "query/ExportVTKNeighbors.hpp"
#include "mesh/Mesh.hpp"
#include "io/ExportVTK.hpp"
#include "mesh/Group.hpp"
#include "utils/Parallel.hpp"
#include "utils/Dimensions.hpp"

#include "tarch/tests/TestCaseFactory.h"
registerTest(precice::tests::GeometryQueriesTest)

namespace precice {
namespace tests {

tarch::logging::Log GeometryQueriesTest:: _log ("precice::tests::GeometryQueriesTest");

GeometryQueriesTest:: GeometryQueriesTest ()
:
   TestCase ("tests::GeometryQueriesTest")
{}

void GeometryQueriesTest:: run ()
{
  PRECICE_MASTER_ONLY {
    preciceTrace ( "run ()" );
    testMethod ( testSphereQueries );
    testMethod ( testDriftRatchetQueries );
    testMethod ( testNumericalAccuracy );
  }
}

void GeometryQueriesTest:: testSphereQueries ()
{
   preciceTrace ( "testSphereQueries()" );
   int dim = 2;
   using utils::Vector2D;
   // Set up sphere geometry
   bool flipNormals = false;
   mesh::Mesh mesh ( "testSphereQueries-Sphere", dim, flipNormals );
   utils::DynVector offset ( Vector2D(0.199938, 1.839938) );
   double discretizationWidth = 0.01;
   double radius = 0.0488;
   geometry::Sphere sphere ( offset, discretizationWidth, radius );
   sphere.create ( mesh );
   // Set up voxel query and closest visitor
   Vector2D inquiryCenter (0.230027434842249633995, 1.87790123456790114531);
   Vector2D inquiryHalflengths (0.000562414);
   query::FindVoxelContent findVoxel (
      inquiryCenter, inquiryHalflengths, query::FindVoxelContent::EXCLUDE_BOUNDARY );
   query::FindClosest findClosest ( inquiryCenter );

   // Query geometry
   query::ExportVTKVoxelQueries exportVoxelQueries;
   query::ExportVTKNeighbors exportNeighbors;

   findVoxel ( mesh );
   exportVoxelQueries.addQuery (
      inquiryCenter, inquiryHalflengths, findVoxel.content().size() );
   findClosest ( mesh );
   exportNeighbors.addNeighbors ( inquiryCenter, findClosest.getClosest() );
   query::FindVoxelContent findVoxelIncludingBounds (
      inquiryCenter, inquiryHalflengths, query::FindVoxelContent::EXCLUDE_BOUNDARY );
   query::FindVoxelContent findVoxelExcludingBounds (
      inquiryCenter, inquiryHalflengths, query::FindVoxelContent::EXCLUDE_BOUNDARY );
   findVoxelIncludingBounds ( mesh );
   findVoxelExcludingBounds ( mesh );


   // Export geometry
   io::ExportVTK exportVTK ( "", true );
   exportVTK.doExport ( "itest-GeometryQueriesTest-testSphereQueries", mesh );
//   exportVoxelQueries.exportQueries ("itest-GeometryQueriesTest-testSphereQueries-voxels");
//   exportNeighbors.exportNeighbors ("itest-GeometryQueriesTest-testSphereQueries-neighbors");

   // Validate results
   validate ( findClosest.getClosest().distance < 0.0 );
   validateEquals ( findVoxelExcludingBounds.content().empty(), false );
}

void GeometryQueriesTest:: testDriftRatchetQueries ()
{
   preciceTrace ( "testDriftRatchetQueries()" );

   // Create drift ratchet geometry
   std::string name ( "test-dratchet" );
   bool flipNormals = false;
   mesh::Mesh mesh ( name, flipNormals );
   Vector offset ( 0.0 );
   double pores = 2.0;
   double length = geometry::DriftRatchet::getCharacteristicLength
                   (geometry::DriftRatchet::getDefaultMaxRadius()) * pores;
   double discretizationWidth = 0.5;
   geometry::DriftRatchet driftRatchet (
      offset, discretizationWidth,
      geometry::DriftRatchet::getDefaultMaxRadius(),
      geometry::DriftRatchet::getDefaultMinRadius(geometry::DriftRatchet::getDefaultMaxRadius()),
      geometry::DriftRatchet::getDefaultShapeParameter(),
      length, pores, 0, 1, 2 );
   driftRatchet.create ( mesh );

   io::ExportVTK exportDRatchet ( "", true );
   exportDRatchet.doExport ( "precice-GeometryQueriesTest-dratchet", mesh );

   // Perform neighbor search queries
   Vector queryPoint0 ( 0.0 );
   queryPoint0(1) = 3.0;
   Vector queryPoint1 ( 0.0 );
   queryPoint1(1) = 0.5;
   int queryCount = 100;
   double queryRange = 18.0;
   double step = queryRange / queryCount;
   query::ExportVTKNeighbors exportVTK;
   for ( int i=0; i < queryCount; i++ ) {
      query::FindClosest find0 ( queryPoint0 );
      find0 ( mesh );
      query::FindClosest find1 ( queryPoint1 );
      find1 ( mesh );
      exportVTK.addNeighbors ( queryPoint0, find0.getClosest() );
      exportVTK.addNeighbors ( queryPoint1, find0.getClosest() );
      queryPoint0(0) += step;
      queryPoint1(0) += step;
   }
   exportVTK.exportNeighbors ( "precice-GeometryQueriesTest-dratchet-neighbors" );
}

void GeometryQueriesTest:: testNumericalAccuracy ()
{
  preciceTrace ( "testNumericalAccuracy()" );

  std::string name ( "TestMesh" );
  bool flipNormals = false;
  mesh::Mesh mesh ( name, flipNormals );

  Vector offset ( 0.0 );
  double h = 1.0;
  Vector sidelengths ( 1.0 );
  geometry::Cuboid cuboid ( offset, h, sidelengths );
  cuboid.create ( mesh );

  utils::Vector voxelCenter ( 0.9 );
  voxelCenter[0] = 1.1;
  utils::Vector voxelHalflengths ( 0.1 );
  {
    query::FindVoxelContent find ( voxelCenter, voxelHalflengths,
                                   query::FindVoxelContent::EXCLUDE_BOUNDARY);
    find ( mesh );
    validateEquals ( find.content().size(), 0 );
  }
  {
    query::FindVoxelContent find ( voxelCenter, voxelHalflengths,
                                   query::FindVoxelContent::INCLUDE_BOUNDARY);
    find ( mesh );
    if ( utils::Def::DIM == 2 ) {
      validateEquals ( find.content().edges().size(), 2 );
      validateEquals ( find.content().vertices().size(), 1 );
    }
    else {
      validate ( find.content().size() > 0 );
    }
  }

  voxelCenter[0] = 1.1 - (tarch::la::NUMERICAL_ZERO_DIFFERENCE / 5.0);
  {

    query::FindVoxelContent find ( voxelCenter, voxelHalflengths,
                                   query::FindVoxelContent::EXCLUDE_BOUNDARY);
    find ( mesh );
    validateEquals ( find.content().size(), 0 );
  }
  {
    query::FindVoxelContent find ( voxelCenter, voxelHalflengths,
                                   query::FindVoxelContent::INCLUDE_BOUNDARY);
    find ( mesh );
    if ( utils::Def::DIM == 2 ) {
      validateEquals ( find.content().edges().size(), 2 );
      validateEquals ( find.content().vertices().size(), 1 );
    }
    else {
      validate ( find.content().size() > 0 );
    }
  }

  voxelCenter[0] = 1.1 + (tarch::la::NUMERICAL_ZERO_DIFFERENCE / 5.0 );
  {

    query::FindVoxelContent find ( voxelCenter, voxelHalflengths,
                                   query::FindVoxelContent::EXCLUDE_BOUNDARY);
    find ( mesh );
    validateEquals ( find.content().size(), 0 );
  }
  {
    query::FindVoxelContent find ( voxelCenter, voxelHalflengths,
                                   query::FindVoxelContent::INCLUDE_BOUNDARY);
    find ( mesh );
    if ( utils::Def::DIM == 2 ) {
      validateEquals ( find.content().edges().size(), 2 );
      validateEquals ( find.content().vertices().size(), 1 );
    }
    else {
      validate ( find.content().size() > 0 );
    }
  }

  voxelCenter[0] = 1.1 - (10.0 * tarch::la::NUMERICAL_ZERO_DIFFERENCE);
  {
    query::FindVoxelContent find ( voxelCenter, voxelHalflengths,
                                   query::FindVoxelContent::EXCLUDE_BOUNDARY);
    find ( mesh );
    if ( utils::Def::DIM == 2 ) {
      validateEquals ( find.content().edges().size(), 1 );
      validateEquals ( find.content().vertices().size(), 0 );
    }
    else {
      validate ( find.content().size() > 0 );
    }
  }
  {
    query::FindVoxelContent find ( voxelCenter, voxelHalflengths,
                                   query::FindVoxelContent::INCLUDE_BOUNDARY);
    find ( mesh );
    if ( utils::Def::DIM == 2 ) {
      validateEquals ( find.content().edges().size(), 2 );
      validateEquals ( find.content().vertices().size(), 1 );
    }
    else {
      validate ( find.content().size() > 0 );
    }
  }
  voxelCenter[1] = 1.0;
  {
    query::FindVoxelContent find ( voxelCenter, voxelHalflengths,
                                   query::FindVoxelContent::EXCLUDE_BOUNDARY);
    find ( mesh );
    if ( utils::Def::DIM == 2 ) {
      validateEquals ( find.content().edges().size(), 2 );
      validateEquals ( find.content().vertices().size(), 1 );
    }
    else {
      validate ( find.content().size() > 0 );
    }
  }
  {
    query::FindVoxelContent find ( voxelCenter, voxelHalflengths,
                                   query::FindVoxelContent::INCLUDE_BOUNDARY);
    find ( mesh );
    if ( utils::Def::DIM == 2 ) {
      validateEquals ( find.content().edges().size(), 2 );
      validateEquals ( find.content().vertices().size(), 1 );
    }
    else {
      validate ( find.content().size() > 0 );
    }
  }
}

}} // namespace precice, tests

