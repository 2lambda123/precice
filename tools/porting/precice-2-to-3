#! /usr/bin/env python

from lxml import etree
import sys
import argparse
import os
import shutil


if sys.version_info < (3, 6):
    raise RuntimeError(
        "This program requires python 3.6 or later but you attempted to run it"
        " with python {}.{}".format(
            sys.version_info.major. sys.version_info.minor
        ))


def isTrue(text):
    return text.lower() in ["yes", "1", "true", "on"]


def quote(text):
    return f'"{text}"'


def parseXML(content):
    p = etree.XMLParser(recover=True, remove_comments=True)
    return etree.fromstring(content, p)


def parseXMLFile(filename):
    return parseXML(open(filename, "rb").read())


def portParticipant(p):
    # use-mesh -> receive-mesh / provide-mesh
    for um in p.findall("use-mesh"):
        if isTrue(um.attrib.get("provide", "false")):
            um.tag = "provide-mesh"
            um.attrib.pop("provide", None)
        else:
            um.tag = "receive-mesh"
            um.attrib.pop("provide", None)

    # mappings
    for m in filter(lambda c: c.tag.startswith("mapping"), p.iterchildren()):
        # scaled-consisitent constraint
        if m.attrib["constraint"] == "scaled-consisitent":
            m.attrib["constraint"] = "scaled-consisitent-surface"

        # rbf mappings
        if m.tag.startswith("mapping:rbf"):
            rbf = m.tag.removeprefix("mapping:rbf-")
            if isTrue(attrib.get("use-qr-decomposition", "false")):
                m.tag = "mapping:rbf-global-iterative"
            else:
                m.tag = "mapping:rbf-global-direct"
            rbfattribs = {k: v for k, v in m.attrib.itmes() if k in ["shape-parameter", "support-radius"]}
            m.append(etree.Element("basis-function:"+rbf, rbfattribs))

    # actions
    removedTimings = ["regular-prior", "regular-post", "on-exchange-prior", "on-exchange-post", "read-mapping-prior", "write-mapping-prior", "on-time-window-complete-post"]
    removedActions = ["ComputeCurvatureAction", "ScaleByDtAction"]
    for a in filter(lambda c: c.tag.startswith("action"), p.iterchildren()):
        if a.tag.removeprefix("action:") in removedActions:
            p.remove(a)
            print(f"Removed: {a.tag} (action unsupported)")
        elif a.tag.removeprefix("action:") in removedActions:
            p.remove(a)
            print(f"Removed: {a.tag} (timing unsupported)")
    return p


def portCouplingScheme(cpl):
    # removed extrapolation order
    for extra in cpl.findall("extrapolation-order"):
        cpl.remove(extra)
        print("Removed: extrapolation-order")
    return cpl


def portConfiguration(root):
    assert root.tag == "precice-configuration"
    # remove SI
    si = root.find("solver-interface")
    if si is None:
        print("This configuration already seems to be a version 3 configuration file.")
        return None
    dims = si.attrib["dimensions"]
    root.attrib.update({"dimensions": dims})
    experimental = si.attrib.get("experimental")
    if experimental:
        root.attrib.update({"experimental": experimental})
    for c in si.iterchildren():
        root.append(c)
    root.remove(si)

    for p in root.findall("participant"):
        p = portParticipant(p)

    for cpl in root.findall("coupling-schemes"):
        cpl = portCouplingScheme(cpl)
    return root


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('infile',  type=str, help="The XML configuration file to update.")
    args = parser.parse_args()

    print("Parsing file")
    root = parseXMLFile(args.infile)
    ported = portConfiguration(root)
    if ported is None:
        sys.exit(1)

    print("Creating backup")
    shutil.copyfile(args.infile, args.infile+".bak")

    print("Writing file")
    tree = etree.ElementTree(ported)
    tree.write(args.infile, pretty_print=True, xml_declaration=True, encoding="utf-8")
    sys.exit(0)
